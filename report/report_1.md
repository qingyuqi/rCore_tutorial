## 练习题1：中断异常
#### 1、rCore中处理异常和中断的流程
* 异常或中断产生，程序进入中断处理总入口，也就是设置好的 **__alltraps**，进入之后在 **trap.asm** 中进行所有通用寄存器（除x0、x2）的保存，以及判断中断来源并判断是否进行内核栈和用户栈的转化。之后跳转到 **rust_trap** 函数进行异常中断处理，处理完毕之后，再把所有通用寄存器恢复，再调用 **sret** 返回。

#### 2、保存寄存器是必须的吗？
* 是必须的，即使是最极端的情况：**ebreak** 触发中断，中断处理没有任何其他操作，但是 **sepc** 作为返回地址仍然被修改，保存寄存器的操作是必须的。

#### 3、编程解决：在任意位置触发一条非法指令异常（如：mret），在 rust_trap 中捕获并对其进行处理
* **触发非法指令异常**：在 **rust_main** 当中使用内联汇编 **asm!("mret"::::"volatile");** 触发异常。在 **rust_trap** 中捕获，将异常类型输出，并触发 **panic**，运行结果如下：
	
	
		Exception(IllegalInstruction)
		panicked at 'undefined trap!', src/interrupt.rs:49:13:49:13
