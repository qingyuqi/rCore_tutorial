## 练习题1：中断异常
#### 1、rCore中处理异常和中断的流程
* 异常或中断产生，程序进入中断处理总入口，也就是设置好的 **__alltraps**，进入之后在 **trap.asm** 中进行所有通用寄存器（除x0、x2）的保存，以及判断中断来源并判断是否进行内核栈和用户栈的转化。之后跳转到 **rust_trap** 函数进行异常中断处理，处理完毕之后，再把所有通用寄存器恢复，再调用 **sret** 返回。

#### 2、保存寄存器是必须的吗？
* 不是必须的，最极端的情况：ebreak触发中断，中断处理当中不改变任何寄存器的值，此时不必保存寄存器。但是对于大部分中断和异常、系统调用来说，大概率会修改某个或某几个寄存器的值，为了保证中断前后寄存器不发生变化，保存寄存器的操作还是很有必要的。

#### 3、编程解决：在任意位置触发一条非法指令异常（如：mret），在 rust_trap 中捕获并对其进行处理
* **触发非法指令异常**：在 **rust_main** 当中使用内联汇编 **asm!("mret"::::"volatile");** 触发异常。在 **rust_trap** 中捕获，将异常类型输出，并触发 **panic**，运行结果如下：
    
	
	Exception(IllegalInstruction)
	panicked at 'undefined trap!', src/interrupt.rs:49:13:49:13